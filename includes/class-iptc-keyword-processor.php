<?php
/**
 * IPTC Keyword Processor Class
 * 
 * Handles extraction and processing of IPTC keywords from images
 */

// Prevent direct access
if (!defined('ABSPATH')) {
    exit;
}

class IPTC_TagMaker_Keyword_Processor {
    
    /**
     * Process IPTC keywords for a post
     * 
     * @param int $post_id The post ID
     * @param bool $force_clear Force clearing of existing tags
     * @return bool Whether processing was successful
     */
    public function process_keywords_for_post($post_id, $force_clear = false) {
        $this->debug_log('Starting IPTC processing for post ID: ' . $post_id, array(
            'force_clear' => $force_clear
        ));
        
        // Get the first image from post content
        $attachment_id = $this->get_first_image_attachment($post_id);
        
        if (!$attachment_id) {
            $this->debug_log('No image found for post ID: ' . $post_id);
            // No image found - clear existing IPTC tags if any
            $this->clear_iptc_generated_tags($post_id);
            return false;
        }
        
        $this->debug_log('Found image attachment ID: ' . $attachment_id . ' for post ID: ' . $post_id);
        
        // Check if this is a different image than last processed
        $last_processed_image = get_post_meta($post_id, '_iptc_last_processed_image', true);
        $image_changed = ($last_processed_image != $attachment_id);
        
        $fullsize_path = get_attached_file($attachment_id);
        
        if (!$fullsize_path || !file_exists($fullsize_path)) {
            return false;
        }

        $info = array();
        $image = getimagesize($fullsize_path, $info);
        
        if (!isset($info['APP13'])) {
            // No IPTC data - clear existing tags if image changed
            if ($image_changed || $force_clear) {
                $this->clear_iptc_generated_tags($post_id);
                update_post_meta($post_id, '_iptc_last_processed_image', $attachment_id);
            }
            return false;
        }

        $iptc = iptcparse($info['APP13']);
        
        if (!$iptc || !isset($iptc["2#025"])) {
            $this->debug_log('No IPTC keywords found in image', array(
                'attachment_id' => $attachment_id,
                'iptc_data_exists' => !empty($iptc),
                'keywords_field_exists' => isset($iptc["2#025"])
            ));
            // No keywords - clear existing tags if image changed
            if ($image_changed || $force_clear) {
                $this->clear_iptc_generated_tags($post_id);
                update_post_meta($post_id, '_iptc_last_processed_image', $attachment_id);
            }
            return false;
        }

        $keywords = $iptc["2#025"];
        $this->debug_log('Found IPTC keywords', array(
            'attachment_id' => $attachment_id,
            'raw_keywords' => $keywords
        ));
        
        $filtered_keywords = $this->filter_keywords($keywords);
        
        // Apply keywords to post (this will handle clearing based on settings)
        $this->apply_keywords_to_post($filtered_keywords, $post_id, $image_changed || $force_clear);
        
        // Track which image we processed
        update_post_meta($post_id, '_iptc_last_processed_image', $attachment_id);
        
        return true;
    }
    
    /**
     * Clear IPTC-generated tags from a post
     * 
     * @param int $post_id Post ID
     */
    private function clear_iptc_generated_tags($post_id) {
        // Get tags that were generated by IPTC processing
        $iptc_tags = get_post_meta($post_id, '_iptc_generated_tags', true);
        
        if (is_array($iptc_tags) && !empty($iptc_tags)) {
            // Remove these specific tags
            $current_tags = wp_get_post_tags($post_id, array('fields' => 'ids'));
            $remaining_tags = array_diff($current_tags, $iptc_tags);
            wp_set_object_terms($post_id, $remaining_tags, 'post_tag');
        }
        
        // Clear the meta
        delete_post_meta($post_id, '_iptc_generated_tags');
    }
    
    /**
     * Get the first image attachment from a post
     * 
     * @param int $post_id The post ID
     * @return int|false The attachment ID or false if none found
     */
    public function get_first_image_attachment($post_id) {
        // Get the first image from post content (not just attachments)
        return $this->catch_that_image($post_id);
    }
    
    /**
     * Get the first image from post content and return its attachment ID
     * This ensures we're processing the actual first image that appears in the post,
     * not just featured images or attachments
     * 
     * @param int $post_id Post ID
     * @return int|false Attachment ID or false if no image found
     */
    private function catch_that_image($post_id) {
        $post = get_post($post_id);
        if (!$post) {
            return false;
        }
        
        $content = $post->post_content;
        
        // Look for images in post content
        $pattern = '/<img[^>]+src=[\'"]([^\'"]+)[\'"][^>]*>/i';
        preg_match_all($pattern, $content, $matches);
        
        if (!empty($matches[1])) {
            foreach ($matches[1] as $image_url) {
                // Convert URL to attachment ID and get original full-size image
                $attachment_id = $this->get_attachment_id_from_url($image_url);
                
                if ($attachment_id) {
                    // Verify this is the original full-size image, not a thumbnail
                    $original_url = wp_get_attachment_url($attachment_id);
                    $attachment_id = $this->ensure_original_image($attachment_id, $image_url);
                    
                    if ($attachment_id) {
                        return $attachment_id;
                    }
                }
            }
        }
        
        // Fallback: Try featured image if no content images found
        $attachment_id = get_post_thumbnail_id($post_id);
        if ($attachment_id) {
            return $attachment_id;
        }
        
        // Final fallback: Try attached images
        $attachments = get_attached_media('image', $post_id);
        if (!empty($attachments)) {
            $first_attachment = reset($attachments);
            return $first_attachment->ID;
        }
        
        return false;
    }
    
    /**
     * Get attachment ID from image URL
     * 
     * @param string $image_url Image URL
     * @return int|false Attachment ID or false
     */
    private function get_attachment_id_from_url($image_url) {
        // Try WordPress built-in function first
        $attachment_id = attachment_url_to_postid($image_url);
        
        if ($attachment_id) {
            return $attachment_id;
        }
        
        // If that fails, try to find by checking if it's a resized version
        // Remove size suffix (e.g., -150x150, -300x200, etc.)
        $image_url_clean = preg_replace('/-\d+x\d+(?=\.[a-z]{3,4}$)/i', '', $image_url);
        
        if ($image_url_clean !== $image_url) {
            $attachment_id = attachment_url_to_postid($image_url_clean);
            if ($attachment_id) {
                return $attachment_id;
            }
        }
        
        return false;
    }
    
    /**
     * Ensure we're working with the original full-size image
     * 
     * @param int $attachment_id Attachment ID
     * @param string $found_url The URL that was found in content
     * @return int|false Original attachment ID or false
     */
    private function ensure_original_image($attachment_id, $found_url) {
        // Get the original full-size URL
        $original_url = wp_get_attachment_url($attachment_id);
        
        if (!$original_url) {
            return false;
        }
        
        // If the found URL is different from original, it might be a thumbnail
        // We always want to process the original full-size image for IPTC data
        $original_path = get_attached_file($attachment_id);
        
        if ($original_path && file_exists($original_path)) {
            return $attachment_id;
        }
        
        return false;
    }
    
    /**
     * Filter keywords based on blocked list and substitutions
     * 
     * @param array $keywords Raw keywords from IPTC
     * @return array Filtered keywords
     */
    private function filter_keywords($keywords) {
        $filtered_keywords = array();
        $blocked_keywords = $this->get_blocked_keywords();
        $keyword_substitutions = $this->get_keyword_substitutions();
        $exclude_substrings = $this->get_exclude_substrings();
        
        $this->debug_log('Starting keyword filtering', array(
            'raw_keywords' => $keywords,
            'blocked_keywords' => $blocked_keywords,
            'keyword_substitutions' => $keyword_substitutions,
            'exclude_substrings' => $exclude_substrings
        ));
        
        foreach ($keywords as $keyword) {
            $keyword_trim = trim($keyword);
            $keyword_lower = strtolower($keyword_trim);
            $original_keyword = $keyword_trim; // Keep track of original for logging
            
            $this->debug_log('Processing keyword: ' . $keyword_trim);
            
            // Skip if blocked
            if (in_array($keyword_trim, $blocked_keywords, true) || 
                in_array($keyword_lower, array_map('strtolower', $blocked_keywords), true)) {
                $this->debug_log('Keyword blocked: ' . $keyword_trim);
                continue;
            }
            
            // Skip if contains excluded substring
            $skip_keyword = false;
            foreach ($exclude_substrings as $needle) {
                if (str_contains($keyword_lower, $needle)) {
                    $this->debug_log('Keyword excluded (contains "' . $needle . '"): ' . $keyword_trim);
                    $skip_keyword = true;
                    break;
                }
            }
            
            if ($skip_keyword) {
                continue;
            }
            
            // Apply substitutions
            $substitution_applied = false;
            foreach ($keyword_substitutions as $original => $replacement) {
                // Clean and normalize both for comparison
                $original_clean = trim(strtolower($original));
                $keyword_clean = trim(strtolower($keyword_trim));
                
                $this->debug_log('Checking substitution', array(
                    'keyword' => $keyword_trim,
                    'original' => $original,
                    'replacement' => $replacement,
                    'match' => ($keyword_clean === $original_clean) ? 'YES' : 'NO'
                ));
                
                if ($keyword_clean === $original_clean) {
                    $this->debug_log('Substitution APPLIED: "' . $keyword_trim . '" -> "' . $replacement . '"');
                    $keyword_trim = $replacement;
                    $substitution_applied = true;
                    break;
                }
            }
            
            if (!$substitution_applied) {
                $this->debug_log('No substitution applied for: ' . $original_keyword);
            }
            
            $filtered_keywords[] = $keyword_trim;
        }
        
        $this->debug_log('Keyword filtering complete', array(
            'input_count' => count($keywords),
            'output_count' => count($filtered_keywords),
            'filtered_keywords' => $filtered_keywords
        ));
        
        return $filtered_keywords;
    }
    
    /**
     * Apply filtered keywords as tags to post
     * 
     * @param array $keywords Filtered keywords
     * @param int $post_id The post ID
     * @param bool $image_changed Whether the source image has changed
     */
    private function apply_keywords_to_post($keywords, $post_id, $image_changed = false) {
        $settings = get_option('iptc_tagmaker_settings', array());
        
        $this->debug_log('Applying keywords to post', array(
            'post_id' => $post_id,
            'keywords' => $keywords,
            'keyword_count' => count($keywords)
        ));
        
        // Determine tag processing mode (with backward compatibility)
        $tag_mode = 'append'; // Default to append
        if (isset($settings['tag_mode'])) {
            $tag_mode = $settings['tag_mode'];
        } elseif (!empty($settings['remove_existing_tags'])) {
            // Backward compatibility: convert old setting
            $tag_mode = 'replace';
        }
        
        $this->debug_log('Tag processing mode', array(
            'tag_mode' => $tag_mode,
            'image_changed' => $image_changed
        ));
        
        // If image changed, always clear IPTC-generated tags first
        if ($image_changed) {
            $this->clear_iptc_generated_tags($post_id);
        }
        
        // Handle tag replacement mode
        if ($tag_mode === 'replace') {
            $this->debug_log('Replacing all existing tags with IPTC keywords');
            wp_set_object_terms($post_id, array(), 'post_tag');
        } else {
            $this->debug_log('Appending IPTC keywords to existing tags');
        }
        
        $tag_ids = array();
        
        foreach ($keywords as $keyword) {
            $this->debug_log('Creating/finding tag for keyword: ' . $keyword);
            $tag_id = $this->get_or_create_tag($keyword);
            
            if ($tag_id) {
                $this->debug_log('Tag created/found successfully', array(
                    'keyword' => $keyword,
                    'tag_id' => $tag_id
                ));
                $tag_ids[] = (int) $tag_id;
            } else {
                $this->debug_log('Failed to create/find tag for keyword: ' . $keyword);
            }
        }
        
        // Apply all tags at once using term IDs instead of names/slugs to avoid comma parsing
        if (!empty($tag_ids)) {
            $append_tags = ($tag_mode === 'append');
            
            $this->debug_log('Applying tags to post', array(
                'tag_ids' => $tag_ids,
                'append_mode' => $append_tags
            ));
            
            wp_set_object_terms(
                $post_id, 
                $tag_ids, 
                'post_tag', 
                $append_tags
            );
            
            // Track which tags were generated by IPTC processing
            update_post_meta($post_id, '_iptc_generated_tags', $tag_ids);
        } else {
            // No keywords to apply, clear the tracking meta
            delete_post_meta($post_id, '_iptc_generated_tags');
        }
    }
    
    /**
     * Get or create a WordPress tag
     * 
     * @param string $tag_name The tag name
     * @return int|null The tag ID or null on error
     */
    private function get_or_create_tag($tag_name) {
        // Clean the tag name
        $tag_name = trim($tag_name);
        
        if (empty($tag_name)) {
            return null;
        }
        
        $term = term_exists($tag_name, 'post_tag');
        
        if ($term !== 0 && $term !== null) {
            $this->debug_log('Tag already exists', array(
                'tag_name' => $tag_name,
                'term_id' => $term['term_id']
            ));
            return $term['term_id'];
        } else {
            // Use wp_insert_term with proper args array to handle commas correctly
            $proposed_slug = sanitize_title($tag_name);
            
            $this->debug_log('Creating new tag', array(
                'tag_name' => $tag_name,
                'proposed_slug' => $proposed_slug
            ));
            
            $term = wp_insert_term(
                $tag_name,  // The term name
                'post_tag', // The taxonomy
                array(
                    'slug' => $proposed_slug
                )
            );
            
            if (is_wp_error($term)) {
                $this->debug_log('Tag creation failed', array(
                    'tag_name' => $tag_name,
                    'error_code' => $term->get_error_code(),
                    'error_message' => $term->get_error_message()
                ));
                return null;
            }
            
            $this->debug_log('Tag created successfully', array(
                'tag_name' => $tag_name,
                'term_id' => $term['term_id'],
                'actual_slug' => get_term($term['term_id'], 'post_tag')->slug ?? 'unknown'
            ));
            
            return $term['term_id'];
        }
    }
    
    /**
     * Get blocked keywords from database
     * 
     * @return array Blocked keywords
     */
    private function get_blocked_keywords() {
        global $wpdb;
        $table_name = $wpdb->prefix . 'iptc_blocked_keywords';
        
        $results = $wpdb->get_col("SELECT keyword FROM $table_name");
        
        return $results ? $results : array();
    }
    
    /**
     * Get keyword substitutions from database
     * 
     * @return array Keyword substitutions (original => replacement)
     */
    private function get_keyword_substitutions() {
        global $wpdb;
        $table_name = $wpdb->prefix . 'iptc_keyword_substitutions';
        
        $results = $wpdb->get_results("SELECT original_keyword, replacement_keyword FROM $table_name", ARRAY_A);
        
        $substitutions = array();
        if ($results) {
            foreach ($results as $row) {
                $substitutions[$row['original_keyword']] = $row['replacement_keyword'];
            }
        }
        
        return $substitutions;
    }
    
    /**
     * Get exclude substrings - removed hardcoded filters, users should control all filtering
     * 
     * @return array Substrings to exclude (empty array - no hardcoded exclusions)
     */
    private function get_exclude_substrings() {
        // No hardcoded exclusions - users control all filtering via blocked keywords
        return array();
    }
    
    /**
     * Add a blocked keyword
     * 
     * @param string $keyword The keyword to block
     * @return bool Success
     */
    public function add_blocked_keyword($keyword) {
        global $wpdb;
        $table_name = $wpdb->prefix . 'iptc_blocked_keywords';
        
        // Clean the keyword the same way we do during import
        $keyword = stripslashes(trim($keyword, '"\''));
        $keyword = trim($keyword);
        
        $result = $wpdb->insert(
            $table_name,
            array('keyword' => $keyword),
            array('%s')
        );
        
        return $result !== false;
    }
    
    /**
     * Remove a blocked keyword
     * 
     * @param string $keyword The keyword to unblock
     * @return bool Success
     */
    public function remove_blocked_keyword($keyword) {
        global $wpdb;
        $table_name = $wpdb->prefix . 'iptc_blocked_keywords';
        
        // Clean the keyword the same way we do during import
        $keyword = stripslashes(trim($keyword, '"\''));
        $keyword = trim($keyword);
        
        $result = $wpdb->delete(
            $table_name,
            array('keyword' => $keyword),
            array('%s')
        );
        
        return $result !== false && $result > 0;
    }
    
    /**
     * Add a keyword substitution
     * 
     * @param string $original Original keyword
     * @param string $replacement Replacement keyword
     * @return bool Success
     */
    public function add_keyword_substitution($original, $replacement) {
        global $wpdb;
        $table_name = $wpdb->prefix . 'iptc_keyword_substitutions';
        
        $result = $wpdb->replace(
            $table_name,
            array(
                'original_keyword' => trim($original),
                'replacement_keyword' => trim($replacement)
            ),
            array('%s', '%s')
        );
        
        return $result !== false;
    }
    
    /**
     * Remove a keyword substitution
     * 
     * @param string $original Original keyword
     * @return bool Success
     */
    public function remove_keyword_substitution($original) {
        global $wpdb;
        $table_name = $wpdb->prefix . 'iptc_keyword_substitutions';
        
        $result = $wpdb->delete(
            $table_name,
            array('original_keyword' => trim($original)),
            array('%s')
        );
        
        return $result !== false;
    }
    
    /**
     * Debug logging helper
     * 
     * @param string $message Message to log
     * @param array $data Additional data to log
     */
    private function debug_log($message, $data = array()) {
        $settings = get_option('iptc_tagmaker_settings', array());
        
        if (empty($settings['debug_logging'])) {
            return;
        }
        
        $log_message = '[IPTC TagMaker] ' . $message;
        
        if (!empty($data)) {
            $log_message .= ' | Data: ' . print_r($data, true);
        }
        
        error_log($log_message);
    }
    

}